# UDP-reliable-data-transfer-java
Implementação de transferência de arquivo sobre socket UDP que implementa mecanismos de transferência confiável de dados do TCP.  
A aplicação foi estruturada seguindo a arquitetura Cliente–Servidor. O lado servidor abrirá um socket UDP e esperará por conexões do cliente. Ao receber uma conexão, o lado servidor irá criar um novo arquivo no sistema de arquivos locais, receber o fluxo de bytes enviado pelo cliente e armazená-lo no arquivo recém-criado. Cada execução do lado servidor da aplicação deve corresponder ao recebimento de um único arquivo. Em outras palavras, após o recebimento de todos os bytes do arquivo, o servidor irá fechar a conexão, fechar o arquivo recém-criado e encerrar sua execução.  
Já o lado cliente deverá deverá receber como entradas do usuário o nome do arquivo a ser transferido para o servidor e o endereço do servidor. O cliente deverá, então, abrirá o arquivo para leitura a partir do sistema de arquivos local e abrir um socket UDP para conexão com o servidor. Deste ponto em diante, o cliente lerá blocos de bytes do arquivo, empacotá-los em um cabeçalho e realizar o envio dos pacotes de maneira confiável para o servidor sobre o socket UDP. Uma vez que o servidor tenha recebido todos o conteúdo do arquivo, o cliente deve encerrar sua execução.  
Os seguintes mecanismos do TCP foram utilizados nesta implementação:  
• **Número de Sequência** – Cada pacote enviado do cliente para o servidor tem um número de sequência informado em seu cabeçalho. Assim como no TCP, os números de sequência foram contados em bytes, e não em pacotes. O número de sequência enviado no cabeçalho de um pacote de dados corresponde ao número de sequência do primeiro byte no pacote. Ao contrário do que ocorre no TCP, no entanto, o número de sequência inicial é sempre 0. O servidor usa os números de sequência para
garantir a correta ordem dos bytes no arquivo recém-criado.  
• **ACKs** – Ao receber pacotes do cliente, o servidor enviará ACKs, reconhecendo a correta recepção do pacote de dados. Assim como no TCP, os ACKs são cumulativos. Em seu cabeçalho, o ACK deverá informar o número de sequência do próximo
byte esperado. Também como feito pelo TCP, no caso de pacotes fora de ordem, o servidor enviará um ACK (possivelmente duplicado) com o número de sequência do próximo byte esperado (em ordem).  
• **Retransmissões** – Ao receber um ACK duplicado, o cliente reenviará o pacote de número de sequência indicado no ACK.  
• **Temporizador** – Assim como no TCP, o cliente manterá um temporizador que determina até quando o cliente deverá esperar pelo ACK de um dado pacote. A manipulação do temporizador é similar à feita pelo TCP. Se, ao transmitir um pacote, não houver temporizador ativo, o mesmo deve ser ativado. Ao receber o ACK não duplicado, o cliente deve desativar o temporizador. Neste caso, se ainda houver outros pacotes em trânsito o temporizador deve ser ativado no vamente com seu valor inicial. Se o temporizador expira, o pacote mais antigo ainda não reconhecido deve ser retransmitido e o temporizador deve ser reativado com seu valor inicial.  
• *Janela de Congestionamento* – O cliente utiliza uma janela de congestionamento que limita o número de pacotes em trânsito (i.e., transmitidos, porém ainda não reconhecidos).  
